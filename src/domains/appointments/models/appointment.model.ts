import { BaseEntity, AppointmentStatus, DateTimeSlot } from "@/shared/types/common.types";

export interface Appointment extends BaseEntity {
  doctorId: string;
  patientId: string;
  appointmentDate: Date;
  startTime: string; // HH:mm format
  endTime: string; // HH:mm format
  status: AppointmentStatus;
  reasonForVisit?: string;
  notes?: string;
  cancellationReason?: string;
  cancelledBy?: string;
  cancelledAt?: Date;
  confirmedAt?: Date;
}

export interface CreateAppointmentData {
  tenantId: string;
  doctorId: string;
  patientId: string;
  appointmentDate: Date;
  startTime: string;
  endTime: string;
  reasonForVisit?: string;
}

export interface UpdateAppointmentData {
  appointmentDate?: Date;
  startTime?: string;
  endTime?: string;
  status?: AppointmentStatus;
  reasonForVisit?: string;
  notes?: string;
  cancellationReason?: string;
  cancelledBy?: string;
  confirmedAt?: Date;
}

export interface AppointmentWithDetails extends Appointment {
  doctorName: string;
  doctorSpecialization: string;
  patientName: string;
  patientEmail: string;
  patientPhone?: string;
}

// Domain methods for Appointment entity
export class AppointmentEntity {
  private constructor(private appointment: Appointment) {}

  static create(data: CreateAppointmentData): AppointmentEntity {
    const appointment: Appointment = {
      id: "", // Will be generated by database
      tenant_id: data.tenantId,
      doctorId: data.doctorId,
      patientId: data.patientId,
      appointmentDate: data.appointmentDate,
      startTime: data.startTime,
      endTime: data.endTime,
      status: AppointmentStatus.SCHEDULED,
      reasonForVisit: data.reasonForVisit,
      created_at: new Date(),
      updated_at: new Date(),
    };

    return new AppointmentEntity(appointment);
  }

  static fromDatabase(data: any): AppointmentEntity {
    const appointment: Appointment = {
      id: data.id,
      tenant_id: data.tenant_id,
      doctorId: data.doctor_id,
      patientId: data.patient_id,
      appointmentDate: new Date(data.appointment_date),
      startTime: data.start_time,
      endTime: data.end_time,
      status: data.status as AppointmentStatus,
      reasonForVisit: data.reason_for_visit,
      notes: data.notes,
      cancellationReason: data.cancellation_reason,
      cancelledBy: data.cancelled_by,
      cancelledAt: data.cancelled_at ? new Date(data.cancelled_at) : undefined,
      confirmedAt: data.confirmed_at ? new Date(data.confirmed_at) : undefined,
      created_at: new Date(data.created_at),
      updated_at: new Date(data.updated_at),
    };

    return new AppointmentEntity(appointment);
  }

  // Getters
  get id(): string {
    return this.appointment.id;
  }

  get tenantId(): string {
    return this.appointment.tenant_id;
  }

  get doctorId(): string {
    return this.appointment.doctorId;
  }

  get patientId(): string {
    return this.appointment.patientId;
  }

  get appointmentDateTime(): Date {
    const [hours, minutes] = this.appointment.startTime.split(":").map(Number);
    const dateTime = new Date(this.appointment.appointmentDate);
    dateTime.setHours(hours, minutes, 0, 0);
    return dateTime;
  }

  get endDateTime(): Date {
    const [hours, minutes] = this.appointment.endTime.split(":").map(Number);
    const dateTime = new Date(this.appointment.appointmentDate);
    dateTime.setHours(hours, minutes, 0, 0);
    return dateTime;
  }

  get status(): AppointmentStatus {
    return this.appointment.status;
  }

  get timeSlot(): DateTimeSlot {
    return {
      start: this.appointmentDateTime,
      end: this.endDateTime,
    };
  }

  // Business logic methods
  canBeCancelled(): boolean {
    return [AppointmentStatus.SCHEDULED, AppointmentStatus.CONFIRMED].includes(this.appointment.status);
  }

  canBeRescheduled(): boolean {
    return [AppointmentStatus.SCHEDULED, AppointmentStatus.CONFIRMED].includes(this.appointment.status);
  }

  canBeConfirmed(): boolean {
    return this.appointment.status === AppointmentStatus.SCHEDULED;
  }

  canBeStarted(): boolean {
    return this.appointment.status === AppointmentStatus.CONFIRMED;
  }

  canBeCompleted(): boolean {
    return this.appointment.status === AppointmentStatus.IN_PROGRESS;
  }

  isInPast(): boolean {
    return this.appointmentDateTime < new Date();
  }

  isToday(): boolean {
    const today = new Date();
    const appointmentDate = this.appointment.appointmentDate;

    return appointmentDate.toDateString() === today.toDateString();
  }

  getTimeUntilAppointment(): number {
    return this.appointmentDateTime.getTime() - new Date().getTime();
  }

  getDurationInMinutes(): number {
    const start = this.appointmentDateTime;
    const end = this.endDateTime;
    return Math.floor((end.getTime() - start.getTime()) / (1000 * 60));
  }

  // State transition methods
  confirm(): void {
    if (!this.canBeConfirmed()) {
      throw new Error("Appointment cannot be confirmed in current state");
    }
    this.appointment.status = AppointmentStatus.CONFIRMED;
    this.appointment.confirmedAt = new Date();
    this.appointment.updated_at = new Date();
  }

  start(): void {
    if (!this.canBeStarted()) {
      throw new Error("Appointment cannot be started in current state");
    }
    this.appointment.status = AppointmentStatus.IN_PROGRESS;
    this.appointment.updated_at = new Date();
  }

  complete(): void {
    if (!this.canBeCompleted()) {
      throw new Error("Appointment cannot be completed in current state");
    }
    this.appointment.status = AppointmentStatus.COMPLETED;
    this.appointment.updated_at = new Date();
  }

  cancel(reason: string, cancelledBy: string): void {
    if (!this.canBeCancelled()) {
      throw new Error("Appointment cannot be cancelled in current state");
    }
    this.appointment.status = AppointmentStatus.CANCELLED;
    this.appointment.cancellationReason = reason;
    this.appointment.cancelledBy = cancelledBy;
    this.appointment.cancelledAt = new Date();
    this.appointment.updated_at = new Date();
  }

  markAsNoShow(): void {
    this.appointment.status = AppointmentStatus.NO_SHOW;
    this.appointment.updated_at = new Date();
  }

  reschedule(newDate: Date, newStartTime: string, newEndTime: string): void {
    if (!this.canBeRescheduled()) {
      throw new Error("Appointment cannot be rescheduled in current state");
    }
    this.appointment.appointmentDate = newDate;
    this.appointment.startTime = newStartTime;
    this.appointment.endTime = newEndTime;
    this.appointment.status = AppointmentStatus.SCHEDULED; // Reset to scheduled
    this.appointment.confirmedAt = undefined;
    this.appointment.updated_at = new Date();
  }

  addNotes(notes: string): void {
    this.appointment.notes = notes;
    this.appointment.updated_at = new Date();
  }

  update(data: UpdateAppointmentData): void {
    Object.assign(this.appointment, {
      ...data,
      updated_at: new Date(),
    });
  }

  // Convert to plain object for API responses
  toJSON(): Appointment {
    return { ...this.appointment };
  }

  // Convert to database format
  toDatabaseFormat(): any {
    return {
      id: this.appointment.id,
      tenant_id: this.appointment.tenant_id,
      doctor_id: this.appointment.doctorId,
      patient_id: this.appointment.patientId,
      appointment_date: this.appointment.appointmentDate,
      start_time: this.appointment.startTime,
      end_time: this.appointment.endTime,
      status: this.appointment.status,
      reason_for_visit: this.appointment.reasonForVisit,
      notes: this.appointment.notes,
      cancellation_reason: this.appointment.cancellationReason,
      cancelled_by: this.appointment.cancelledBy,
      cancelled_at: this.appointment.cancelledAt,
      confirmed_at: this.appointment.confirmedAt,
      created_at: this.appointment.created_at,
      updated_at: this.appointment.updated_at,
    };
  }

  // Get raw appointment data
  getRawData(): Appointment {
    return { ...this.appointment };
  }

  // Check for time conflicts with another appointment
  conflictsWith(other: AppointmentEntity): boolean {
    if (this.appointment.appointmentDate.toDateString() !== other.appointment.appointmentDate.toDateString()) {
      return false;
    }

    const thisStart = this.appointmentDateTime;
    const thisEnd = this.endDateTime;
    const otherStart = other.appointmentDateTime;
    const otherEnd = other.endDateTime;

    // Check for overlap
    return thisStart < otherEnd && otherStart < thisEnd;
  }
}
