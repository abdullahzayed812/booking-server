import { BaseEntity, DayOfWeek, TimeSlot } from "@/shared/types/common.types";

export interface Doctor extends BaseEntity {
  userId: string; // References users.id
  specialization: string;
  licenseNumber?: string | undefined;
  bio?: string | undefined;
  consultationFee?: number | undefined;
  consultationDuration: number; // in minutes
  isAcceptingAppointments: boolean;
}

export interface DoctorAvailability extends BaseEntity {
  doctorId: string;
  dayOfWeek: DayOfWeek;
  startTime: string; // HH:mm format
  endTime: string; // HH:mm format
  isActive: boolean;
}

export interface AvailabilityOverride extends BaseEntity {
  doctorId: string;
  date: Date;
  startTime?: string | undefined; // null means unavailable all day
  endTime?: string | undefined;
  isAvailable: boolean;
  reason?: string | undefined;
}

export interface DoctorWithUser extends Doctor {
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  isActive: boolean;
  isVerified: boolean;
}

export interface CreateDoctorData {
  tenantId: string;
  userId: string;
  specialization: string;
  licenseNumber?: string | undefined;
  bio?: string | undefined;
  consultationFee?: number | undefined;
  consultationDuration?: number | undefined;
}

export interface UpdateDoctorData {
  specialization?: string;
  licenseNumber?: string;
  bio?: string;
  consultationFee?: number;
  consultationDuration?: number;
  isAcceptingAppointments?: boolean;
}

export interface CreateAvailabilityData {
  tenantId: string;
  doctorId: string;
  dayOfWeek: DayOfWeek;
  startTime: string;
  endTime: string;
}

export interface CreateAvailabilityOverrideData {
  tenantId: string;
  doctorId: string;
  date: Date;
  startTime?: string | undefined;
  endTime?: string | undefined;
  isAvailable: boolean;
  reason?: string | undefined;
}

// Domain methods for Doctor entity
export class DoctorEntity {
  private constructor(private doctor: Doctor) {}

  static create(data: CreateDoctorData): DoctorEntity {
    const doctor: Doctor = {
      id: "", // Will be generated by database
      tenant_id: data.tenantId,
      userId: data.userId,
      specialization: data.specialization,
      licenseNumber: data.licenseNumber,
      bio: data.bio,
      consultationFee: data.consultationFee,
      consultationDuration: data.consultationDuration || 30,
      isAcceptingAppointments: true,
      created_at: new Date(),
      updated_at: new Date(),
    };

    return new DoctorEntity(doctor);
  }

  static fromDatabase(data: any): DoctorEntity {
    const doctor: Doctor = {
      id: data.id,
      tenant_id: data.tenant_id,
      userId: data.user_id || data.id, // Handle both cases
      specialization: data.specialization,
      licenseNumber: data.license_number,
      bio: data.bio,
      consultationFee: data.consultation_fee ? parseFloat(data.consultation_fee) : undefined,
      consultationDuration: data.consultation_duration || 30,
      isAcceptingAppointments: Boolean(data.is_accepting_appointments),
      created_at: new Date(data.created_at),
      updated_at: new Date(data.updated_at),
    };

    return new DoctorEntity(doctor);
  }

  // Getters
  get id(): string {
    return this.doctor.id;
  }

  get tenantId(): string {
    return this.doctor.tenant_id;
  }

  get userId(): string {
    return this.doctor.userId;
  }

  get specialization(): string {
    return this.doctor.specialization;
  }

  get isAcceptingAppointments(): boolean {
    return this.doctor.isAcceptingAppointments;
  }

  get consultationDuration(): number {
    return this.doctor.consultationDuration;
  }

  // Business logic methods
  canAcceptAppointments(): boolean {
    return this.doctor.isAcceptingAppointments;
  }

  toggleAcceptingAppointments(): void {
    this.doctor.isAcceptingAppointments = !this.doctor.isAcceptingAppointments;
    this.doctor.updated_at = new Date();
  }

  updateProfile(data: UpdateDoctorData): void {
    Object.assign(this.doctor, {
      ...data,
      updated_at: new Date(),
    });
  }

  // Convert to plain object for API responses
  toJSON(): Doctor {
    return { ...this.doctor };
  }

  // Convert to database format
  toDatabaseFormat(): any {
    return {
      id: this.doctor.id,
      tenant_id: this.doctor.tenant_id,
      user_id: this.doctor.userId,
      specialization: this.doctor.specialization,
      license_number: this.doctor.licenseNumber,
      bio: this.doctor.bio,
      consultation_fee: this.doctor.consultationFee,
      consultation_duration: this.doctor.consultationDuration,
      is_accepting_appointments: this.doctor.isAcceptingAppointments,
      created_at: this.doctor.created_at,
      updated_at: this.doctor.updated_at,
    };
  }

  getRawData(): Doctor {
    return { ...this.doctor };
  }
}

// Domain methods for DoctorAvailability entity
export class DoctorAvailabilityEntity {
  private constructor(private availability: DoctorAvailability) {}

  static create(data: CreateAvailabilityData): DoctorAvailabilityEntity {
    const availability: DoctorAvailability = {
      id: "",
      tenant_id: data.tenantId,
      doctorId: data.doctorId,
      dayOfWeek: data.dayOfWeek,
      startTime: data.startTime,
      endTime: data.endTime,
      isActive: true,
      created_at: new Date(),
      updated_at: new Date(),
    };

    return new DoctorAvailabilityEntity(availability);
  }

  static fromDatabase(data: any): DoctorAvailabilityEntity {
    const availability: DoctorAvailability = {
      id: data.id,
      tenant_id: data.tenant_id,
      doctorId: data.doctor_id,
      dayOfWeek: data.day_of_week as DayOfWeek,
      startTime: data.start_time,
      endTime: data.end_time,
      isActive: Boolean(data.is_active),
      created_at: new Date(data.created_at),
      updated_at: new Date(data.updated_at),
    };

    return new DoctorAvailabilityEntity(availability);
  }

  get id(): string {
    return this.availability.id;
  }

  get doctorId(): string {
    return this.availability.doctorId;
  }

  get dayOfWeek(): DayOfWeek {
    return this.availability.dayOfWeek;
  }

  get timeSlot(): TimeSlot {
    return {
      start: this.availability.startTime,
      end: this.availability.endTime,
    };
  }

  get isActive(): boolean {
    return this.availability.isActive;
  }

  activate(): void {
    this.availability.isActive = true;
    this.availability.updated_at = new Date();
  }

  deactivate(): void {
    this.availability.isActive = false;
    this.availability.updated_at = new Date();
  }

  updateTimes(startTime: string, endTime: string): void {
    this.availability.startTime = startTime;
    this.availability.endTime = endTime;
    this.availability.updated_at = new Date();
  }

  toJSON(): DoctorAvailability {
    return { ...this.availability };
  }

  toDatabaseFormat(): any {
    return {
      id: this.availability.id,
      tenant_id: this.availability.tenant_id,
      doctor_id: this.availability.doctorId,
      day_of_week: this.availability.dayOfWeek,
      start_time: this.availability.startTime,
      end_time: this.availability.endTime,
      is_active: this.availability.isActive,
      created_at: this.availability.created_at,
      updated_at: this.availability.updated_at,
    };
  }

  getRawData(): DoctorAvailability {
    return { ...this.availability };
  }
}

// Domain methods for AvailabilityOverride entity
export class AvailabilityOverrideEntity {
  private constructor(private override: AvailabilityOverride) {}

  static create(data: CreateAvailabilityOverrideData): AvailabilityOverrideEntity {
    const override: AvailabilityOverride = {
      id: "",
      tenant_id: data.tenantId,
      doctorId: data.doctorId,
      date: data.date,
      startTime: data.startTime,
      endTime: data.endTime,
      isAvailable: data.isAvailable,
      reason: data.reason,
      created_at: new Date(),
      updated_at: new Date(),
    };

    return new AvailabilityOverrideEntity(override);
  }

  static fromDatabase(data: any): AvailabilityOverrideEntity {
    const override: AvailabilityOverride = {
      id: data.id,
      tenant_id: data.tenant_id,
      doctorId: data.doctor_id,
      date: new Date(data.date),
      startTime: data.start_time,
      endTime: data.end_time,
      isAvailable: Boolean(data.is_available),
      reason: data.reason,
      created_at: new Date(data.created_at),
      updated_at: new Date(data.updated_at),
    };

    return new AvailabilityOverrideEntity(override);
  }

  get id(): string {
    return this.override.id;
  }

  get doctorId(): string {
    return this.override.doctorId;
  }

  get date(): Date {
    return this.override.date;
  }

  get isAvailable(): boolean {
    return this.override.isAvailable;
  }

  get timeSlot(): TimeSlot | null {
    if (!this.override.startTime || !this.override.endTime) {
      return null; // All day unavailable
    }
    return {
      start: this.override.startTime,
      end: this.override.endTime,
    };
  }

  isAllDayUnavailable(): boolean {
    return !this.override.isAvailable && (!this.override.startTime || !this.override.endTime);
  }

  updateAvailability(isAvailable: boolean, startTime?: string, endTime?: string, reason?: string): void {
    this.override.isAvailable = isAvailable;
    this.override.startTime = startTime;
    this.override.endTime = endTime;
    this.override.reason = reason;
    this.override.updated_at = new Date();
  }

  toJSON(): AvailabilityOverride {
    return { ...this.override };
  }

  toDatabaseFormat(): any {
    return {
      id: this.override.id,
      tenant_id: this.override.tenant_id,
      doctor_id: this.override.doctorId,
      date: this.override.date,
      start_time: this.override.startTime,
      end_time: this.override.endTime,
      is_available: this.override.isAvailable,
      reason: this.override.reason,
      created_at: this.override.created_at,
      updated_at: this.override.updated_at,
    };
  }

  getRawData(): AvailabilityOverride {
    return { ...this.override };
  }
}
