import { AuthUser } from "@/shared/types/auth.types";
import { BaseEntity, UserRole } from "@/shared/types/common.types";

export interface User extends BaseEntity {
  email: string;
  passwordHash: string;
  firstName: string;
  lastName: string;
  phone?: string | undefined;
  dateOfBirth?: Date | undefined;
  role: UserRole;
  isActive: boolean;
  isVerified: boolean;
  emailVerifiedAt?: Date | undefined;
  lastLoginAt?: Date | undefined;
  passwordChangedAt: Date;
  tokenVersion: number;
  deletedAt?: Date | undefined;
}

export interface CreateUserData {
  tenantId: string;
  email: string;
  passwordHash: string;
  firstName: string;
  lastName: string;
  phone?: string | undefined;
  dateOfBirth?: Date | undefined;
  role: UserRole;
}

export interface UpdateUserData {
  firstName?: string;
  lastName?: string;
  phone?: string;
  dateOfBirth?: Date;
  isActive?: boolean;
  isVerified?: boolean;
  emailVerifiedAt?: Date;
  lastLoginAt?: Date;
}

export interface UserWithProfile extends User {
  // Doctor-specific fields (if role is doctor)
  specialization?: string;
  licenseNumber?: string;
  bio?: string;
  consultationFee?: number;
  consultationDuration?: number;
  isAcceptingAppointments?: boolean;

  // Patient-specific fields (if role is patient)
  medicalRecordNumber?: string;
  emergencyContactName?: string;
  emergencyContactPhone?: string;
  bloodType?: string;
  allergies?: string;
  medicalHistory?: string;
}

// Domain methods for User entity
export class UserEntity {
  private constructor(private user: User) {}

  static create(data: CreateUserData): UserEntity {
    const user: User = {
      id: "", // Will be generated by database
      tenant_id: data.tenantId,
      email: data.email,
      passwordHash: data.passwordHash,
      firstName: data.firstName,
      lastName: data.lastName,
      phone: data.phone,
      dateOfBirth: data.dateOfBirth,
      role: data.role,
      isActive: true,
      isVerified: false,
      passwordChangedAt: new Date(),
      tokenVersion: 0,
      created_at: new Date(),
      updated_at: new Date(),
    };

    return new UserEntity(user);
  }

  static fromDatabase(data: any): UserEntity {
    const user: User = {
      id: data.id,
      tenant_id: data.tenant_id,
      email: data.email,
      passwordHash: data.password_hash,
      firstName: data.first_name,
      lastName: data.last_name,
      phone: data.phone,
      dateOfBirth: data.date_of_birth ? new Date(data.date_of_birth) : undefined,
      role: data.role as UserRole,
      isActive: Boolean(data.is_active),
      isVerified: Boolean(data.is_verified),
      emailVerifiedAt: data.email_verified_at ? new Date(data.email_verified_at) : undefined,
      lastLoginAt: data.last_login_at ? new Date(data.last_login_at) : undefined,
      passwordChangedAt: new Date(data.password_changed_at),
      tokenVersion: data.token_version,
      created_at: new Date(data.created_at),
      updated_at: new Date(data.updated_at),
      deletedAt: data.deleted_at ? new Date(data.deleted_at) : undefined,
    };

    return new UserEntity(user);
  }

  // Getters
  get id(): string {
    return this.user.id;
  }

  get tenantId(): string {
    return this.user.tenant_id;
  }

  get email(): string {
    return this.user.email;
  }

  get fullName(): string {
    return `${this.user.firstName} ${this.user.lastName}`;
  }

  get role(): UserRole {
    return this.user.role;
  }

  get isActive(): boolean {
    return this.user.isActive;
  }

  get isVerified(): boolean {
    return this.user.isVerified;
  }

  get tokenVersion(): number {
    return this.user.tokenVersion;
  }

  get lastLoginAt(): Date | undefined {
    return this.user.lastLoginAt;
  }

  get passwordChangedAt(): Date {
    return this.user.passwordChangedAt;
  }

  // Business logic methods
  canLogin(): boolean {
    return this.user.isActive && !this.user.deletedAt;
  }

  needsEmailVerification(): boolean {
    return !this.user.isVerified;
  }

  isPasswordExpired(maxAge: number = 90 * 24 * 60 * 60 * 1000): boolean {
    const now = new Date();
    const passwordAge = now.getTime() - this.user.passwordChangedAt.getTime();
    return passwordAge > maxAge;
  }

  markAsLoggedIn(): void {
    this.user.lastLoginAt = new Date();
    this.user.updated_at = new Date();
  }

  markEmailAsVerified(): void {
    this.user.isVerified = true;
    this.user.emailVerifiedAt = new Date();
    this.user.updated_at = new Date();
  }

  updatePassword(newPasswordHash: string): void {
    this.user.passwordHash = newPasswordHash;
    this.user.passwordChangedAt = new Date();
    this.user.tokenVersion += 1; // Invalidate all existing tokens
    this.user.updated_at = new Date();
  }

  invalidateTokens(): void {
    this.user.tokenVersion += 1;
    this.user.updated_at = new Date();
  }

  deactivate(): void {
    this.user.isActive = false;
    this.user.updated_at = new Date();
  }

  activate(): void {
    this.user.isActive = true;
    this.user.updated_at = new Date();
  }

  update(data: UpdateUserData): void {
    Object.assign(this.user, {
      ...data,
      updated_at: new Date(),
    });
  }

  // Convert to plain object for API responses
  toJSON(): Omit<User, "passwordHash"> {
    const { passwordHash, ...userWithoutPassword } = this.user;
    return userWithoutPassword;
  }

  // Convert to database format
  toDatabaseFormat(): any {
    return {
      id: this.user.id,
      tenant_id: this.user.tenant_id,
      email: this.user.email,
      password_hash: this.user.passwordHash,
      first_name: this.user.firstName,
      last_name: this.user.lastName,
      phone: this.user.phone,
      date_of_birth: this.user.dateOfBirth,
      role: this.user.role,
      is_active: this.user.isActive,
      is_verified: this.user.isVerified,
      email_verified_at: this.user.emailVerifiedAt,
      last_login_at: this.user.lastLoginAt,
      password_changed_at: this.user.passwordChangedAt,
      token_version: this.user.tokenVersion,
      created_at: this.user.created_at,
      updated_at: this.user.updated_at,
      deleted_at: this.user.deletedAt,
    };
  }

  toAuthUser(): AuthUser {
    return {
      id: this.user.id,
      email: this.user.email,
      firstName: this.user.firstName,
      lastName: this.user.lastName,
      role: this.user.role,
      tenantId: this.user.tenant_id,
      isActive: this.user.isActive,
      isVerified: this.user.isVerified,
      lastLoginAt: this.user.lastLoginAt!,
      createdAt: this.user.created_at,
      updatedAt: this.user.updated_at,
    };
  }

  // Get raw user data (for internal use)
  getRawData(): User {
    return { ...this.user };
  }
}
